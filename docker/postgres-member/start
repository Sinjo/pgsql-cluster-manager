#!/usr/bin/env bash

set -eu

function cleanup() {
  docker kill pg01 pg02 pg03 magenta carmen >/dev/null 2>&1
  docker rm -f pg01 pg02 pg03 magenta carmen >/dev/null 2>&1
}

cleanup || echo "cleaned up"

function run-container() {
  local id
  id=$(
  docker run \
    --name "$1" \
    --hostname "$1" \
    --privileged \
    --detach \
    --publish-all \
    --volume "/var/run/docker.sock:/var/run/docker.sock" \
    --volume "$(pwd)/stonith/docker:/usr/lib/stonith/plugins/external/docker" \
    --volume "${HOSTS}:/etc/hosts" \
    gocardless/postgres-member \
    sh -c "while :; do sleep 1; done")
  ip=$(docker inspect "$id" | jq -r '.[0].NetworkSettings.IPAddress')

  for script in scripts/*.bash; do
    docker cp "$script" "${id}:/bin/"
  done
  echo "$ip $1" >> "$HOSTS"
  echo "$ip"
}

# node-exec <container> <cmd>...
function node-exec() {
  docker exec "$1" "${@:2}"
}

function start-postgres() {
  node-exec "$1" sudo -u postgres mkdir -p /var/lib/postgresql/9.4/tmp
  node-exec "$1" sudo -u postgres /usr/lib/postgresql/9.4/bin/pg_ctl \
    -o '-c config_file=/etc/postgresql/9.4/main/postgresql.conf -p 5432' \
    -D /var/lib/postgresql/9.4/main \
    -l /var/log/postgresql/postgresql-crm.log start
}

function stop-postgres() {
  echo -e "[$1]\tstopping postgres..."
  node-exec "$1" sudo -u postgres /usr/lib/postgresql/9.4/bin/pg_ctl \
    -o '-c config_file=/etc/postgresql/9.4/main/postgresql.conf -p 5432' \
    -D /var/lib/postgresql/9.4/main \
    -l /var/log/postgresql/postgresql-crm.log -m fast stop
}

function promote-postgres() {
  echo -e "[$1]\tpromoting postgres..."
  node-exec "$1" sudo -u postgres /usr/lib/postgresql/9.4/bin/pg_ctl \
    -o '-c config_file=/etc/postgresql/9.4/main/postgresql.conf -p 5432' \
    -D /var/lib/postgresql/9.4/main \
    -l /var/log/postgresql/postgresql-crm.log promote
}

function reload-postgres() {
  echo -e "[$1]\treloading postgres..."
  docker exec -t "$1" sudo -u postgres psql -P pager -c "select pg_reload_conf();"
}

# write-file <container> <filepath>
function write-file() {
  echo -e "[$1]\twriting file $2..."
  docker exec -i "$1" bash -c "cat > $2"
}

# create-recovery-conf <container> <primary_conn_ip>
function create-recovery-conf() {
  echo -e "[$1]\tcreating recovery.conf from $2..."
  cat <<EOF | write-file "$1" /var/lib/postgresql/9.4/main/recovery.conf
standby_mode = 'on'
primary_conninfo = 'host=$2 port=5432 user=postgres application_name=$1 keepalives_idle=60 keepalives_interval=5 keepalives_count=5'
restore_command = 'exit 0'
recovery_target_timeline = 'latest'
EOF
}

# create-rep-mode <container> <standby-names>
function create-rep-mode() {
  echo -e "[$1]\tcreating rep_mode.conf..."
  cat <<EOF | write-file "$1" /var/lib/postgresql/9.4/tmp/rep_mode.conf
synchronous_standby_names = '$2'
EOF
}

# stat-replication <container>
function stat-replication() {
  docker exec -t "$1" sudo -u postgres psql \
    -c "select application_name,state,sync_state,sync_priority from pg_stat_replication;"
}

# start-pacemaker <container> <cluster-node>...
function start-pacemaker() {
  echo -e "[$1]\tstarting pacemaker..."
  docker exec -t "$1" /bin/start_pacemaker.bash "$2" "$3" "$4"
}

HOSTS=$(mktemp "$(pwd)/tmp/hosts.XXXXXX")
chmod 666 "$HOSTS"
echo """
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
""" >> "$HOSTS"

MAGENTA=$(run-container magenta)
CARMEN=$(run-container carmen)
PG01=$(run-container pg01)
PG02=$(run-container pg02)
PG03=$(run-container pg03)

MODE=${1:-slow}

if [ "$MODE" == "fast" ]; then
  echo "starting cluster immediately..."
  docker exec --detach pg01 /bin/start_pacemaker.bash "$PG01" "$PG02" "$PG03"
  docker exec --detach pg02 /bin/start_pacemaker.bash "$PG01" "$PG02" "$PG03"
  docker exec --detach pg03 /bin/start_pacemaker.bash "$PG01" "$PG02" "$PG03"
  exit 0
fi

start-postgres magenta # standalone, single primary

create-recovery-conf carmen "$MAGENTA" # prepare for replication
start-postgres carmen # start replicating

create-rep-mode magenta 'carmen' # mark carmen as a sync standby
reload-postgres magenta # activate the standby config

create-recovery-conf pg03 "$MAGENTA" # prepare for replication
start-postgres pg03

create-rep-mode magenta 'carmen,pg03'
reload-postgres magenta

# THIS IS PRESENT SITUATION ####################################################

read -p "this is our present situation, press enter to start recovery"

# node-maintenance <container> <maintenance>
function node-maintenance() {
  echo -e "[$1]\tcrm node maintenance $2..."
  docker exec -t "$1" crm node maintenance "$2"
}

# wait-for-quorum <container>
function wait-for-quorum() {
  echo -n "waiting for quorum..."
  until docker exec -t "$1" crm status | grep -q 'with quorum'; do
      sleep 1 && printf "."
  done
  echo " done!"
}

# wait-for-sync <container>
function wait-for-sync() {
  echo -n "waiting for master and sync..."
  until docker exec -t "$1" crm node list | grep -q '|SYNC'; do
      sleep 1 && printf "."
  done
  echo " done!"
}

# pg-basebackup <container> <source>
function pg-basebackup() {
  echo -e "[$1]\tremoving Postgres data directory..."
  docker exec "$1" sh -c 'rm -rf /var/lib/postgresql/9.4/main'
  echo -e "[$1]\trunning pg_basebackup from $2..."
  node-exec "$1" \
    sudo -u postgres pg_basebackup \
    -P -D /var/lib/postgresql/9.4/main -X stream \
    -v -h "$2" -U postgres
}

# Start pacemaker on pg01 & pg02, leaving pg03 off
start-pacemaker pg01 "$PG01" "$PG02" "$PG03"
start-pacemaker pg02 "$PG01" "$PG02" "$PG03"

wait-for-quorum pg01
node-exec pg01 /bin/configure_pacemaker.bash pg01 pg02 pg03
wait-for-sync pg01

MASTER="$(node-exec pg01 bash -c "crm node list | grep -B1 LATEST | head -n1 | cut -d'(' -f1")"
MASTER="${MASTER/$'\r'/}"

SYNC="$(node-exec pg01 bash -c "crm node list | grep -B1 SYNC | head -n1 | cut -d'(' -f1")"
SYNC="${SYNC/$'\r'/}"

echo "identified $MASTER as master node"

node-maintenance "$MASTER" pg01
node-maintenance "$MASTER" pg02

stop-postgres "$SYNC" # this Postgres needs to freeze for a bit
pg-basebackup "$SYNC" "$PG03" # backup from our async
create-recovery-conf "$SYNC" "$MASTER" # prepare for replication from master
create-rep-mode "$SYNC" '' # we want no sync nodes

stop-postgres "$MASTER"
pg-basebackup "$MASTER" "$PG03" # backup from our async
create-recovery-conf "$MASTER" "$MAGENTA" # prepare for replication from magenta
create-rep-mode "$MASTER" '' # we want no sync nodes
start-postgres "$MASTER" # start replicating

# carmen is sync, pg03 is async, but we want the master to become the new sync
create-rep-mode magenta "$MASTER,carmen"
reload-postgres magenta

read -p "return when $MASTER becomes sync of old cluster"

promote-postgres "$MASTER"
node-exec "$MASTER" crm node ready "$MASTER"

read -p "$MASTER should now be managed by pacemaker"

node-exec "$SYNC" crm node ready "$SYNC"

read -p "$SYNC should now be sync node from $MASTER, and managed by pacemaker"

stop-postgres pg03
pg-basebackup pg03 "$SYNC"
start-pacemaker pg03 "$PG01" "$PG02" "$PG03"

echo "pg03 should now become potential, and is managed by pacemaker"
