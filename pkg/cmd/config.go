package cmd

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"os"

	"github.com/BurntSushi/toml"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

func NewConfigCommand(ctx context.Context) *cobra.Command {
	c := &cobra.Command{
		Use:   "config <subcommand>",
		Short: "Configuration helpers",
	}

	c.AddCommand(NewConfigShowCommand(ctx))

	return c
}

type configShowCommand struct {
	out io.Writer
}

func NewConfigShowCommand(ctx context.Context) *cobra.Command {
	show := &configShowCommand{out: os.Stdout}
	c := &cobra.Command{
		Use:   "show",
		Short: "Prints configuration values",
		Long:  "Can be used to generate a template configuration file with sensible default values",
		RunE:  func(cmd *cobra.Command, _ []string) error { return show.Run(cmd) },
		Example: `
  # Generate a config.toml that can then be passed as a flag to --config-file
  pgcm config show >/etc/pgsql-cluster-manager/config.toml`,
	}

	return c
}

func (s *configShowCommand) Run(cmd *cobra.Command) error {
	var err error
	var configBuffer bytes.Buffer

	write := func(s string) {
		if err == nil {
			_, err = configBuffer.WriteString(s)
		}
	}

	write("# Generated by `pgcm show-config`\n")
	write("# See pgcm --help for more detailed usage\n")
	write("# https://github.com/gocardless/pgsql-cluster-manager\n\n")

	walkFlags(cmd.Root(), func(flag *pflag.Flag) {
		if flag.Name == "help" || flag.Name == "config-file" {
			return
		}

		write(fmt.Sprintf("# %s\n", flag.Usage))
		toml.NewEncoder(&configBuffer).Encode(map[string]interface{}{
			flag.Name: viper.Get(flag.Name),
		})
		write("\n")
	})

	if err == nil {
		fmt.Fprint(s.out, configBuffer.String())
	}

	return err
}

func walkFlags(cmd *cobra.Command, cb func(*pflag.Flag)) {
	cmd.NonInheritedFlags().VisitAll(cb)

	for _, cmd := range cmd.Commands() {
		walkFlags(cmd, cb)
	}
}
